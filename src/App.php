<?php

namespace eazy\http;

use eazy\base\Exception;
use eazy\di\Di;
use eazy\Eazy;
use eazy\http\base\BaseApp;
use eazy\http\di\Container;
use eazy\http\exceptions\CoroutineException;
use eazy\http\exceptions\InvalidConfigException;
use Swoole\Coroutine;
use Swoole\Http\Request;
use Symfony\Component\Console\Tester\TesterTrait;
use Symfony\Component\DependencyInjection\ContainerBuilder;

/**
 * @property \eazy\http\Response $response
 */
class App extends BaseObject
{

    /**
     * @var $this
     */
    private static $_component;

    /**
     * @var \eazy\http\ServiceLocator
     */
    public static $locator;

    /**
     * Autoload class map.
     *
     * @var
     */
    private static $_classMap;

    /**
     * Context pool.
     *
     * @var
     */
    public static $pool;

    public static $attributes;

    /**
     * Alias map.
     *
     * @var
     */
    private static $aliases;

    public function init()
    {
        self::$locator = new ServiceLocator();
        parent::init(); // TODO: Change the autogenerated stub
    }

    /**
     * App::get(component::class);
     * App::get()->component
     *
     * @param  string  $component  component name.
     *
     * @return \eazy\http\Request|\eazy\http\ServiceLocator
     * @throws \eazy\http\exceptions\InvalidConfigException
     */
    public static function get()
    {
        return self::$_component;
    }

    /**
     * Autoload php class.
     *
     * @param $className
     */
    public static function autoload($className)
    {
        if (isset(self::$_classMap[$className])) {
            $classFile = self::$classMap[$className];
            if ($classFile[0] === '@') {
                $classFile = self::getAlias($classFile);
            }
        } elseif (strpos($className, '\\') !== false) {
            $classFile =
                self::getAlias('@'.str_replace('\\', '/', $className).'.php',
                    false);
            if ($classFile === false || ! is_file($classFile)) {
                return;
            }
        } else {
            return;
        }

        include $classFile;

        if ( ! class_exists($className, false)
            && ! interface_exists($className, false)
            && ! trait_exists($className, false)
        ) {
            throw new UnknownClassException("Unable to find '$className' in file: $classFile. Namespace missing?");
        }
    }

    public static function getAlias($alias)
    {
        if (strpos($alias, '@') !== 0) {
            // not an alias
            return $alias;
        }

        $pos = strpos($alias, '/');
        $root = $pos === false ? $alias : substr($alias, 0, $pos);

        if (isset(self::$aliases[$root])) {
            if (is_string(self::$aliases[$root])) {
                return $pos === false ? self::$aliases[$root]
                    : self::$aliases[$root].substr($alias, $pos);
            }

            foreach (self::$aliases[$root] as $name => $path) {
                if (strpos($alias.'/', $name.'/') === 0) {
                    return $path.substr($alias, strlen($name));
                }
            }
        }

        return false;
    }

    public static function setAlias($alias, $path)
    {
        if (strncmp($alias, '@', 1)) {
            $alias = '@'.$alias;
        }
        $pos = strpos($alias, '/');
        $root = $pos === false ? $alias : substr($alias, 0, $pos);
        if ($path !== null) {
            $path = strncmp($path, '@', 1) ? rtrim($path, '\\/')
                : self::getAlias($path);
            if ( ! isset(static::$aliases[$root])) {
                if ($pos === false) {
                    self::$aliases[$root] = $path;
                } else {
                    self::$aliases[$root] = [$alias => $path];
                }
            } elseif (is_string(self::$aliases[$root])) {
                if ($pos === false) {
                    self::$aliases[$root] = $path;
                } else {
                    self::$aliases[$root] = [
                        $alias => $path, $root => self::$aliases[$root],
                    ];
                }
            } else {
                self::$aliases[$root][$alias] = $path;
                krsort(self::$aliases[$root]);
            }
        } elseif (isset(self::$aliases[$root])) {
            if (is_array(self::$aliases[$root])) {
                unset(self::$aliases[$root][$alias]);
            } elseif ($pos === false) {
                unset(self::$aliases[$root]);
            }
        }
    }

    public static function createObject($definition, $params = [])
    {
        if (is_string($definition)) {
            $definition =  array_merge(['class' => $definition], $params);
        }elseif (is_array($definition)) {
            if (!isset($definition['class'])) {
                throw new InvalidConfigException("Invalid definition. must be set class params.");
            }
        }

        if (is_object($definition)) {
            return $definition;
        }
        $ref = new \ReflectionClass($definition['class']);
        unset($definition['class']);
        return $ref->newInstanceArgs([$definition]);
    }


    public static function info($message)
    {
        return self::stdout("[INFO]".print_r($message, true).PHP_EOL);
    }

    public static function error($message)
    {
        return self::stdout("[ERROR]".print_r($message, true).PHP_EOL);
    }

    public static function stdout($message)
    {
        return fwrite(\STDOUT, "[" . date('Y-m-d H:i:s') . "]" . $message);
    }

    public function __get($name)
    {
        if (isset(self::$_component[$name])) {
            return self::$_component[$name];
        }

        throw new InvalidConfigException("unknown component");
    }
}